# Advent of Code 2021
My Repository for Advent of Code 2021. The plan was to do all of the exercises in pure C, but after doing the first 2 days I felt like C has too much Bookkeeping so I started using F#. After that i really wanted to try out some different languages and after hearing about Tsodings challenge last year i decided to copy it: Solving the puzzles for each day in a different language and documenting my thoughts.

# List of Languages
* Day1: C
* Day2: F#
* Day3: Ruby

# Notes:
* C: I wanted to get back into C. After working mostly in C# and Java, i really liked the idea of having a lean and small language. But what i got was a lean and small language (monkeys paw i guess): Working with the Files is cumbersome, there is a lot of bookkeeping to do (after revisiting the Code i noticed i was leaking the File) and you're just working at a low abstraction level in general (unless you either roll your own stdlib or work in a big project like the linux kernel). Those are all things i wanted from C, but after using it for only one and a half days i was already done with it. I kept just wanting to test out my ideas without worrying about all the details that don't matter. It really kills your productivity to have to worry about a lot of stuff besides the problem itself. (Also don't be to harsh on my code, i haven't touched C in like 4 years)
* F#: I was taught F# in my first Semester at University. I liked it back then and i enjoyed it now. In my dayjob i mostly work with C# and i completely forgot how much i wished having functions in C# when i first started learing it. The amount of boilerplate is acutally insane (looking at you "private static readonly string ..."). There are just a lot of scenarios where a class is not the right abstraction for the job imo (and others where they are like collections for example, or any situation where you need to manage and hide internal state). So now to F# itself: I really love having a powerful Typesystem, that Op-type feels so natural to create and it is so obvious (to me atleast) to work with it. Having Tuples and Records for plain data is great too, i'm speaking from past experience here, because i didn't really use them in this program. In my opinion a lot of programs and algorithms are expressed really clearly and succinctly in a functional style (especially HOF, recursion more rarely) and F# being functional first encourages that way of solving problems. The best part is that F# doesn't force you to write everything purely functional: Some things are just best described in a procedual style, sometimes it is best to just loop instead of writing complicated helper functions (or maybe i am just to inexperienced in functional programming), writing procedual code in F# is actually pretty seamless (you feel that mutability is discouraged but it is far from the ungodly monstrocity that is precedual haskell). The interop with the C# and the rest of .net feels pretty good too (took me some time to notice that seq is just an alias to IEnumerable), ofcourse some things are a bit awkward to use and F# seems to have a different name for most C# types (kinda confusing), but it is leaps ahead of scala imo. Also being .net and part of .net core, hands down the best tooling of any functional language (access to pretty much all of nuget and easy interop with native methods is great too), such a shame that adoption is low and Microsoft seems to not care that much anymore either.
