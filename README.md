# Advent of Code 2021
My Repository for Advent of Code 2021. The plan was to do all of the exercises in pure C, but after doing the first 2 days I felt like C has too much Bookkeeping so I started using F#. After that i really wanted to try out some different languages and after hearing about Tsodings challenge last year i decided to copy it: Solving the puzzles for each day in a different language and documenting my thoughts.

# List of Languages
* Day1: C
* Day2: F#
* Day3: Ruby
* Day4: Rust
* Day5: Python

# Notes:
* C: I wanted to get back into C. After working mostly in C# and Java, i really liked the idea of having a lean and small language. But what i got was a lean and small language (monkeys paw i guess): Working with the Files is cumbersome, there is a lot of bookkeeping to do (after revisiting the Code i noticed i was leaking the File) and you're just working at a low abstraction level in general (unless you either roll your own stdlib or work in a big project like the linux kernel). Those are all things i wanted from C, but after using it for only one and a half days i was already done with it. I kept just wanting to test out my ideas without worrying about all the details that don't matter. It really kills your productivity to have to worry about a lot of stuff besides the problem itself. (Also don't be to harsh on my code, i haven't touched C in like 4 years)
* F#: I was taught F# in my first Semester at University. I liked it back then and i enjoyed it now. In my dayjob i mostly work with C# and i completely forgot how much i wished having functions in C# when i first started learing it. The amount of boilerplate is acutally insane (looking at you "private static readonly string ..."). There are just a lot of scenarios where a class is not the right abstraction for the job imo (and others where they are like collections for example, or any situation where you need to manage and hide internal state). So now to F# itself: I really love having a powerful Typesystem, that Op-type feels so natural to create and it is so obvious (to me atleast) to work with it. Having Tuples and Records for plain data is great too, i'm speaking from past experience here, because i didn't really use them in this program. In my opinion a lot of programs and algorithms are expressed really clearly and succinctly in a functional style (especially HOF, recursion more rarely) and F# being functional first encourages that way of solving problems. The best part is that F# doesn't force you to write everything purely functional: Some things are just best described in a procedual style, sometimes it is best to just loop instead of writing complicated helper functions (or maybe i am just to inexperienced in functional programming), writing procedual code in F# is actually pretty seamless (you feel that mutability is discouraged but it is far from the ungodly monstrocity that is precedual haskell). The interop with the C# and the rest of .net feels pretty good too (took me some time to notice that seq is just an alias to IEnumerable), ofcourse some things are a bit awkward to use and F# seems to have a different name for most C# types (kinda confusing), but it is leaps ahead of scala imo. Also being .net and part of .net core, hands down the best tooling of any functional language (access to pretty much all of nuget and easy interop with native methods is great too), such a shame that adoption is low and Microsoft seems to not care that much anymore either.
* Rust: First hour of the challenge i was fighting the borrow checker (of course), but after that i that i felt like i had a pretty good feeling what it was gonna complain about and tried to think of another way to accomplish what i want. Surprisingly most of my Rust code **feels** robust, a feeling that i almost never get when programming in general. OVerall feels like a modern, better thought out C++. The only thing that i will say is that i don't think Rust is made for writing quick and dirty programs (because it just disallows them), which is unfortunate if you don't like switching ecosystems that much (like me). I wrote the whole of input parsing and task1 in one go, without ever running the Program which feels crazy when coming from any other language and at the same time is huge compliment to Rust-Analyzer. Without those error messages it would have been impossible to get anything done. (In a way Rust-Analyzer bridges the feedback gap between compiled languages and scripting languages, which is huge to me)
* Python: I mean it's python: great for writing skripts and prototyping, imo really bad for writing bigger projects in a maintainable way. At work we have some automation in python and all of the skript tend to become hard to maintain even though we try to keep them as clean as possible.
